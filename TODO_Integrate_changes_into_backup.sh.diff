diff --git a/backup.sh b/backup.sh
index 7b4c650..6f4d0d5 100755
--- a/backup.sh
+++ b/backup.sh
@@ -16,6 +16,20 @@ ANIMATION_PID=0
 
 ESTIMATED_BACKUP_SIZE_IN_KB=0
 
+is_backup_drive_mounted() {
+  linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows="$(echo "${BACKUP_DIR}" | cut -d '/' -f 2 | tr '[:upper:]' '[:lower:]'):"
+
+  backup_drive_info="$(df | grep --ignore-case "${linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows}")"
+
+  if [ ${backup_drive_info} -eq 0 ]
+  then
+    echo "Backup drive not mounted."
+    echo "Make sure the drive is inserted and has assigned a drive letter."
+ 
+    exit 2
+  fi
+}
+
 start_support_processes() {
   "${SCRIPT_DIR}"/utils/ShutdownGuard/ShutdownGuard.exe &
   SHUTDOWNGUARD_PID="$!"
@@ -42,7 +56,7 @@ clean_temp_files() {
   mkdir --parents "${TMP_DIR}"
   } >> "${LOG_FILE}" 2>&1
   
-  printf "¤ Clearing temporary files\n"
+  printf "¤ Cleaning temporary files\n"
  
   # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
   #"${SCRIPT_DIR}/utils/windows_cleaner/windows_cleaner-clean.sh"
@@ -130,33 +144,8 @@ check_free_space() {
   
   "${SCRIPT_DIR}"/utils/busy-animation.sh &
   ANIMATION_PID="$!"
-
-  linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows="$(echo "${BACKUP_DIR}" | cut -d '/' -f 2 | tr '[:upper:]' '[:lower:]'):"
-  
-  backup_drive_info="$(df | grep --ignore-case "${linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows}" | wc -l)"
-  
-  # Is backup drive mounted?
-  if [ ${backup_drive_info} -eq 0 ]
-  then
-    echo "  • Backup drive not mounted."
-    
-    kill $ANIMATION_PID
-    wait $ANIMATION_PID 2>/dev/null
-    
-    kill $SHUTDOWNGUARD_PID 2>/dev/null
-    wait $SHUTDOWNGUARD_PID 2>/dev/null
-
-    SHUTDOWNGUARD_WINPID="$(ps --windows | grep ShutdownGuard | tr -s ' ' | cut -d ' ' -f5)"
-    taskkill //F //PID "${SHUTDOWNGUARD_WINPID}" 1>/dev/null 2>&1
-    tskill "${SHUTDOWNGUARD_WINPID}" 1>/dev/null 2>&1
-
-    # TODO replace the file path with a variable
-    rm --force "/tmp/currently_backed_up_file.txt"
-    
-    exit 2
-  fi
-
-  free_space_on_disk_with_backup_dir_at_start=$(df | grep --ignore-case "${linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows}" | tr -s '[:space:]' | cut -d ' ' -f 4)
+ 
+  free_space_on_disk_with_backup_dir_at_start=$(df | grep --ignore-case "${linux_style_backup_disk_mountpoint_of_backup_dir_in_git_bash_in_windows}" | tr --squeeze-repeats '[:space:]' | cut --delimiter=' ' --fields=4)
   
   printf "%s\n" "  • Free space on backup drive: ${free_space_on_disk_with_backup_dir_at_start} kB"
 
@@ -203,7 +192,7 @@ generate_files_and_dirs_list() {
 
   printf "%s\n" "  • generate source list of paths"
   # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
-  <"${TMP_DIR}/backup_source_paths.tmp" xargs -I "{}" sh -c "find "{}" >> "${TMP_DIR}/source_files_and_dirs_paths.tmp" 2>/dev/null"
+  <"${TMP_DIR}/backup_source_paths.tmp" xargs -I "{}" sh -c "find "{}" -type f > "${TMP_DIR}/source_files_and_dirs_paths.tmp" 2>/dev/null"
 
   printf "%s\n" "  • generate destination list of paths"
   # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
@@ -212,6 +201,18 @@ generate_files_and_dirs_list() {
   printf "%s\n" "  • generate combined list of paths"
   # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
   paste --delimiter=';' "${TMP_DIR}/source_files_and_dirs_paths.tmp" "${TMP_DIR}/destination_files_and_dirs_paths.tmp" > "${TMP_DIR}/source_and_destination_files_and_dirs_paths.tmp"
+ 
+  printf "%s\n" "  • generate source list of path for directories only"
+  # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
+  # TODO fix unusual filenames handling
+  #   'find -print0 | xargs -0 stops at the first entry in the 'backup_source_paths.tmp'
+  #   With the default '-print' method it creates all the directories on the backup dir for seamless copying
+  #   so maybe rename all files and dirs that contain tabs, newlines, spaces at the beginning/end in the name...?
+  <"${TMP_DIR}/backup_source_paths.tmp" xargs -I "{}" sh -c "find "{}" -type d > "${TMP_DIR}/backup_source_dirs.tmp" 2>/dev/null"
+
+  printf "%s\n" "  • generate destination list of path for directories only"
+  # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
+  cut --delimiter='/' --fields=2 --complement "${TMP_DIR}/backup_source_dirs.tmp" | sed "s:^:${BACKUP_DIR}:g" > "${TMP_DIR}/backup_destination_dirs.tmp" 2>/dev/null
 
   kill $ANIMATION_PID
   wait $ANIMATION_PID 2>/dev/null
@@ -227,15 +228,22 @@ estimate_backup_duration() {
   "${SCRIPT_DIR}"/utils/busy-animation.sh &
   ANIMATION_PID="$!"
 
-  number_of_logs="$(find "${LOG_DIR}" -type f | wc -l)"
-  
-  # TODO make the estimation of backup time more robust by looking for the latest log file with completed and successful backup
-  if [ $number_of_logs -ge 2 ]
-  then
-    forelast_backup_log=$(find "${LOG_DIR}" -type f | sort --reverse | head -n 2 | tail -n 1)
-    start_timestamp=$(head -n 1 "${forelast_backup_log}" | cut -d ':' -f1)
-    end_timestamp=$(tail -n 2 "${forelast_backup_log}" | tr -d '\n' | cut -d ':' -f1)
+  grep --recursive --word-regexp "LOG_BACKUP_INFO - Cleanup - Start Time" "${LOG_DIR}" | sort --reverse | cut --delimiter=':' --fields=1 > "${TMP_DIR}/log_files_with_start_time.tmp"
+
+  grep --recursive --word-regexp "LOG_BACKUP_INFO - Finish - End Time" "${LOG_DIR}" | sort --reverse | cut --delimiter=':' --fields=1 > "${TMP_DIR}/log_files_with_end_time.tmp"
+
+  comm -12 "${TMP_DIR}/log_files_with_start_time.tmp" "${TMP_DIR}/log_files_with_end_time.tmp" > "${TMP_DIR}/log_files_with_start_and_end_time.tmp"
+
+  latest_complete_backup_log="$(head --lines=1 "${TMP_DIR}/log_files_with_start_and_end_time.tmp")"
+
+  if [ -n "$latest_complete_backup_log" ]
+    start_timestamp=$(head -n 1 "${latest_complete_backup_log}" | cut -d ':' -f1)
+    end_timestamp=$(tail -n 2 "${latest_complete_backup_log}" | tr -d '\n' | cut -d ':' -f1)
     duration_of_last_backup_in_seconds=$(( end_timestamp - start_timestamp ))
+
+    # TODO remove
+    #duration_of_last_backup_in_seconds="9876"
+
     duration_of_last_backup_in_seconds_in_human_readable_format=$(date -d@${duration_of_last_backup_in_seconds} -u "+%-k hod. %M minut")
 
     kill $ANIMATION_PID
@@ -256,6 +264,9 @@ estimate_backup_duration() {
 }
 
 backup_files_and_folders() {
+  printf "\n"
+  printf "%s\n" "¤ Back up files and folders"
+
   disk_with_backup_dir_in_git_bash_in_windows="$(echo "${BACKUP_DIR}" | cut -d '/' -f 2):"
   
   "${SCRIPT_DIR}"/utils/busy-animation.sh "${ESTIMATED_BACKUP_SIZE_IN_KB}" "${disk_with_backup_dir_in_git_bash_in_windows}" &
@@ -265,7 +276,23 @@ backup_files_and_folders() {
   echo "$(date "+%s"):$(date "+%Y/%m/%d %H:%M:%S") - LOG_BACKUP_INFO - Backup Files And Folders - Start Time"
   echo
   } >> "${LOG_FILE}"
+
+  printf "%s\n" "  • Creating mirrorred directory structure on backup drive"
+
+  while IFS= read -r line
+  do
+    line_length="${#line}"
+    if [ $line_length -gt 260 ]
+    then
+      echo "$(date "+%s"):$(date "+%Y/%m/%d %H:%M:%S") - LOG_BACKUP_INFO - Dir Path Length Check - This path has ${line_length} characters which is more than 260 characters for file path which probably exceeds the limit of the Win32 API. Consider shortening the names of directories or the file." >> "${LOG_FILE}"
+    fi
+
+    # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
+    mkdir --verbose --parents "${line}" >> "${LOG_FILE}" 2>&1
+  done < "${TMP_DIR}/backup_destination_dirs.tmp"
   
+  printf "%s\n" "  • Backing up files..."
+
   while IFS= read -r line
   do
     source_file="$(echo ${line} | cut --delimiter=';' --fields=1)"
@@ -275,9 +302,9 @@ backup_files_and_folders() {
     #printf "%s\n%s\n\n" "${source_file}" "${destination_file}"
     #sleep 5
 
-    if [ -d "${TMP_DIR}/source_files_and_dirs_paths.tmp" ]; then
-      mkdir --parents "${destination_file}" >> "${LOG_FILE}" 2>&1
-    fi
+    #if [ -d "${source_file}" ]; then
+    #  mkdir --parents "${destination_file}" >> "${LOG_FILE}" 2>&1
+    #fi
 
     # Send the busy-animation the path to currently copied file...
     #   - SKIP - try first whether the log file will be refreshed after every append of currently copied file to test file flushing in shell script
@@ -291,6 +318,7 @@ backup_files_and_folders() {
     printf "%s" "${source_file}" > "/tmp/currently_backed_up_file.txt"
 
     # THIS COMMAND CAN BE TIME-CONSUMING. Comment out for faster debugging/execution
+    #TODO use XCOPY utility from Windows?
     cp --verbose --force --preserve=mode,ownership,timestamps "${source_file}" "${destination_file}" >> "${LOG_FILE}" 2>&1
   done < "${TMP_DIR}/source_and_destination_files_and_dirs_paths.tmp"
  
@@ -358,6 +386,7 @@ handle_Ctrl_C_interrupt() {
 }
 
 main() {
+  is_backup_drive_mounted
   start_support_processes
   show_info_message
   clean_temp_files
@@ -366,12 +395,11 @@ main() {
   estimate_backup_size
   check_free_space
   generate_files_and_dirs_list
-  
-  # TODO test this function - adjustment are dependent on function backup_files_and_folders - final log line - detection of backup completed time
-  #estimate_backup_duration
+  estimate_backup_duration
 
   backup_files_and_folders
-  #finalize_backup
+
+  finalize_backup
 }
 
 main
